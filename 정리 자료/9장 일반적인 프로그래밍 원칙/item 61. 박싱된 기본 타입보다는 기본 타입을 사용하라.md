# item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

<aside>
💡 박싱된 기본타입은 유용한 기능이 많지만 단점도 있다. 기본 타입을 사용해야 하는 이유를 알아보자

</aside>

### 기본 타입과 박싱된 기본 타입(참조 타입)

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수 있다.

하지만 둘의 차이점은 있다.

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다
    
    ⇒ 박싱된 기본 타입의 값이 같아도 서로 다르다고 식별될 수 있다.
    
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입의 값(null)을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

이 세 가지 차이 때문에 주의하지 않고 사용하면 진짜 문제가 생길 수 있다.

### 박싱된 기본 타입의 식별성(identity)로 인한 문제

```java
// 코드 61-1 잘못 구현된 비교자 - 문제를 찾아보자!
Comparator<Integer> naturalOrderV1 = (i, j) -> i < j ? -1 : (i == j ? 0 : 1);

System.out.println(naturalOrderV1.compare(new Integer(42), new Integer(42))); // 0이 출력되야 할 것 같지만 1이 출력된다.
```

두 인스턴스의 값이 42로 같으므로 0을 출력해야 할 것 같지만 1을 출력한다. 

첫번 째 검사 `i < j` 에서는 정상적으로 작동한다. 여기서 i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환된다.

두번 째 검사 `i == j` 에서 문제가 발생한다.

이 두번 째 검사에서는 ‘객체 참조’의 식별성을 검사하게 된다. 

i와 j가 서로 다른 Integer 인스턴스라면 (비록 값이 같더라도) 이 비교의 결과는 false가 되고, 비교자는 잘못된 결과인 1을 반환한다.

**이 처럼 같은 객체를 비교하는 게 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.**

실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder()를 사용하자

비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다. 

그렇더라도 위 문제를 고치기 위해서는 지역변수를 2개 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다.

```java
// 코드 61-2 문제를 수정한 비교자
Comparator<Integer> naturalOrderV2 = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    return i < j ? -1 : (i == j ? 0 : 1);
};
```

### 박싱된 기본 타입의 null 허용으로 인한 문제

```java
// 코드 61-3 기이하게 동작하는 프로그램 - 결과를 맞춰보자
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) { // NPE 발생!!
            System.out.println("믿을 수 없군!");
        }
    }
}
```

위 코드에서 i는 초기화하지 않았으므로 null로 초기화 된다.

조건문 (i == 42)를 수행할 때 Integer 와 int를 비교하게 되는데, 

이와 같이 **기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 거의 예외없이 박싱된 기본 타입의 박싱이 자동으로 풀린다.**

⇒ null 참조를 언박싱하면 NPE가 발생하게 된다.

### 박싱된 기본 타입의 성능 문제

```java
 // 코드 61-4 끔직이 느리다! 객체가 만들어지는 위치를 찾았는 가?
    public static void main(String[] args) {
        Long sum = 0L;
        long beforeTime = System.currentTimeMillis();

        for (long i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }
        System.out.println(sum);

        long afterTime = System.currentTimeMillis();
        System.out.println("소요 시간(m) : " + (afterTime - beforeTime) / 1000);
    }
```

실수로 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다.

위 코드는 소요시간이 10초 가량 걸렸는데 Long sum을 long sum으로 바꾸니 1초만에 수행이 완료되었다.

### 박싱된 기본 타입은 언제 사용해야 할까?

1. 컬렉션의 원소, 키, 값으로 쓴다. 
    
    ⇒ 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야한다
    
    ⇒ 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야한다.
    
2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

### 정리

기본 타입과 박싱된 기본 타입 중 하나를 선택해야한다면 가능하면 기본 타입을 사용하라

기본 타입이 간단하고 빠르다. 박싱된 기본 타입을 써야한다면 주의를 기울이자.

**오토박싱이 박싱된 기본 타입을 사용할 때의 번거러움을 줄여주지만, 그 위험까지 없애주지는 않는다.**

두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄진다.

**같은 연산에서 기본 타입의 박싱된 기본 타입을 혼용하면 언박싱이 이뤄져 성능이 나빠질 수 있다.**

**언박싱 과정에서 NPE가 날 수 있다.**

기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.