# item 69. 예외는 진짜 예외 상황에만 사용하라

<aside>
💡 예외의 본래 목적이 아닌 흐름제어용으로 사용했을 경우에 대한 문제점을 알아보자

</aside>

### 예외를 완전 잘못 사용한 예

```java
// 코드 69-1 예외를 완전히 잘못 사용한 예
try {
    int i = 0;
    while (true){
        range[i++].climb();
    }
} catch (ArrayIndexOutOfBoundsException e) {
}
```

위 코드는 배열의 원소를 순회하는데, 무한 루프를 돌다가 배열의 끝에 도달해 `ArrayIndexOutOfBoundsException` 이 발생하면 끝을 낸다.

예외를 예외 상황에 쓴 것이 아니라 다른 목적으로 사용한 예다.

전혀 직관적이지 않다.

```java
// 표준적인 관용구대로 작성한 코드
for (Mountain m : range) {
    m.climb();
}
```

그냥 표준적인 관용구대로 작성한 경우이다.

**예외를 제어 흐름용으로 사용한 코드의 단점**

1. 표준적인 관용구대로 작성한 코드보다 훨씬 느리다.
2. 반복문안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 한다.
    
    ⇒ 표준적으로 관용구로 작성한 코드 : 호출한 메서드 내부에서 관련 없는 배열을 사용하다 `ArrayIndexOutOfBoundsException` 가 났을 때 예외를 잡지 않고 스택 트레이스를 남기고 스레드를 종료시킨다.
    
    ⇒ 예외를 사용한 반복문 : 버그 때문에 발생한 엉뚱한 예외를 정상적인 종료 상황으로 오해하고 넘어간다.
    
3. 직관성이 떨어지고 유지보수가 쉽지 않다.

위 코드가 주는 교훈은 간단하다.

**예외는 (그 이름이 말해주듯) 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로는 쓰여선 안된다.**

**잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.**

특정 상태에서만 호출할 수 있는 ‘상태 의존적’ 메서드를 제공하는 클래스는 ‘상태 검사’ 메서드도 함께 제공해야 한다.

`Iterator` 인터페이스의 next와 hasNext가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.

별도의 상태 검사 메서드 덕분에 다음과 같은 표준 for 관용구를 사용할 수 있다.

```java
for (Iterator<Mountain> i = collection.iterator(); i.hasNext();) {
    Mountain next = i.next();
}
```

`Iterator`가 hasNext를 제공하지 않았다면 그 일을 클라이언트가 대신해야만 했다.

```java
// 컬렉션을 이런 식으로 순회하지 말 것!
try {
    Iterator<Mountain> i = collection.iterator();
    while (true) {
        Mountain mountain = i.next();
    }
} catch (NoSuchElementException e) {

} 
```

69-1 코드와 상당히 비슷해보인다.

반복문에 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에서 발생한 버그를 숨기기도 한다.

상태 검사 대신 사용할 수 있는 선택지로 올바르지 않은 상태일 시 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법도 있다.

### 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

1. **외부동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.** 
    
    상태 검사 메서드와 상태 의존적 메서드 호출사이에 객체의 상태가 변할 수 있기 때문이다.
    
2. **성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.**

1. **다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.**
    
    가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기 쉽다.
    
    상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값을 검사하지 않고 지나쳐도 발견하기가 어렵다.
    

### 정리

예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.