# item 85. 자바 직렬화의 대안을 찾으라

<aside>
💡 직렬화의 문제점과 그 대안에 대해 알아보자

</aside>

### 직렬화의 문제

공격 범위가 넓고 지속적으로 더 넓어져 방어하기 어렵다.

ObjectInputStream의 readObject 메서드는 (Serializable 인터페이스를 구현했다면) 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있는 마법같은 생성자이다.

바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있다.

⇒ 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.

**로버트 시커드의 말**

> 자바의 역직렬화는 명백하고 현존하는 위험이다. 이 기술은 지금도 애플리케이션에서 직접 혹은, 자바 하부 시스템(RMI, JMX, JMS)을 통해 간접적으로 쓰이고 있기 때문이다.
신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행(remote code excution, RCE), 서비스 거부(denial-of-service, DoS) 등의 공격으로 이어질 수 있다. 
잘못한게 아무 것도 없는 애플리케이션이라도 이런 공격에 취약해질 수 있다.
> 

### 가젯(RCE)

공격자와 보안 전문가들은 자바 라이브러리와 널리 쓰이는 서드파티 라이브러리에서 직렬화 가능 타입들을 연구하여 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드를 가젯이라고 부른다.

여러 가젯을 사용하여 가젯 체인을 구성하여 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 강력한 체인이 발견되고 한다.

그래서 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 한다.

### 역직렬화 폭탄(DoS)

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화 하는 것 만으로도 서비스 거부 공격에 노출될 수 있다.

이런 스트림을 역직렬화 폭탄(deserialization bomb)이라고 한다.

**HashSet과 문자열을 사용해 만든 역직렬화 폭탄 예제**

```java
// 코드 85-1 역직렬화 폭탄 - 이 스트림의 역직렬화는 영원히 계속된다
static byte[] bomb(){
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = new HashSet<>();
    Set<Object> s2 = new HashSet<>();

    for (int i = 0; i < 100; i++) {
        HashSet<Object> t1 = new HashSet<>();
        HashSet<Object> t2 = new HashSet<>();
        t1.add("foo"); // t1을 t2와 다르게 만든다
        s1.add(t1); s1.add(t2);
        s2.add(t1); s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root);// 간결하게 하기 위해 이 메서드 코드는 생략함
}
```

이 객체 그래프는 201개의 HashSet 인스턴스로 구성되며, 그 각각은 3개의 하위 객체 참조를 갖는다.

스트림의 전체 크기는 5744바이트지만, 역직렬화는 영원히 끝나지 않는다.

문제는 HashSet 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야 한다는 데 있다.

루트 HashSet에 담긴 두 원소는 각각 (루트와 마찬가지로) 다른 HashSet 2개씩을 원소로 갖는 HashSet이다.

그리고 반복문에 의해 이 구조가 깊이 100단계까지 만들어진다.

따라서 이 HashSet을 역직렬화하려면 hashCode 메서드를 2^100번 넘게 호출해야된다.

⇒ 문제는 영원히 계속된다는 것도 문제지만, 무언가 잘못되었다는 신호도 주지 않는다는 것이 큰 문제다.

### 해결책

애초에 신뢰할 수 없는 바이드 스트림을 역직렬화하는 일 자체가 스스로를 공격에 노출하는 행위다.

1. **직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**

**우리가 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.**

1. **크로스-플랫폼 구조화된 데이터 표현의 선두주자 : JSON과 프로토콜 버퍼**

대신 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다.

이런 메커니즘을 직렬화 시스템이라 불린다. 작자는 자바직렬화와 구분하기 위해 크로스 플랫폼 구조화 된 데이터 표현(cross-platform-structured-data representation)이라 한다.

이 표현들의 공통점은 자바 직렬화보다 훨씬 간단하다는 것이다.

임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않는다.

대신 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다. 그리고 기본 타입 몇개와 배열 타입만 지원할 뿐이다.

이런 간단한 추상화 만으로도 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을 회피할 수 있음이 밝혀졌다.

대표적인 크로스-플랫폼 구조화된 데이터 표현에는 JSON과 프로토콜 버퍼가 있다.

**JSON** 

- 브라우저와 서버의 통신용으로 설계
- 자바 스크립트 용으로 처음에 만들어졌다.
- 텍스트 기반 표현에 효과적이라 사람이 읽기 편하다.
- 데이터를 표현하는 데만 사용한다.

**프로토콜 버퍼**

- 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 C++용으로 설계
- 이진 표현이라 효율이 좋다.
- 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다.
- 이지 표현 뿐만 아니라 사람이 읽을 수 있는 텍스트 표현도 지원

### **자바 직렬화를 완전히 배제할 수 없을 때 차선책**

1. **신뢰할 수 없는 데이트는 절대 역직렬화하지 않는다.**

신뢰할 수 없는 발신원으로부터의 RMI는 절대 수용해서는 안 된다.

자바 공식 보안 코딩 지침에는 “신뢰할 수 없는 데이터의 역직렬화는 본질적으로 위험하므로 절대로 피해야 한다”라고 조언한다.

1. **역직렬화 필터링**

역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter)를 사용하자

자바 9에 추가되었고 이전 버전에서도 쓸 수 있도록 이식되었다.

객체 역직렬화 필터링은 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다.

클래스 단위로, 특정 클래스를 받아드리거나 거부할 수 있다.

**‘기본 수용’ 모드**에서는 **블랙리스트**에 기록된 잠재적으로 위험한 클래스들을 거부한다.

반대로 **‘기본 거부’ 모드**에서는 **화이트리스트**에 기록된 안전하다고 알려진 클래스만 수용한다.

블랙리스트 방식보다는 **화이트리스트 방식을 추천**한다.

블랙리스트 방식은 이미 알려진 위험으로부터만 보호할 수 있기 때문이다.

### 정리

직렬화는 위험하니 직렬화 대신 JSON이나 프로토콜 버퍼를 사용하자.

신뢰할 수 없는 데이터는 역직렬화하지 말고, 꼭 해야 한다면 객체 역직렬화 필터링을 사용하자