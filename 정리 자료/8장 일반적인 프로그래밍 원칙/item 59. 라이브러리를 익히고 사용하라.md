# item 59. 라이브러리를 익히고 사용하라

<aside>
💡 직접 구현하기보다 이미 만들어진 라이브러리를 익히고 사용하자

</aside>

### random 메서드를 직접 구현하였을 때 문제점

```java
// 코드 59-1 흔하지만 문제가 심각한 코드
static Random rnd = new Random();

private static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}

public static void main(String[] args) {
    int n = 2 *  (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i = 0; i < 1000000; i++) {
        if (random(n) < n/2) {
            low++;
        }
    }
    System.out.println(low); // 500000 근처의 값이 나올 것을 기대하지만 666666에 가까운 값이 나온다.
}

==== output =====
666636
```

직접 구현한 random 메서드이 문제점

- n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.
- n이 2의 제곱수가 아니라면 얼마 지나지 않아 같은 수열이 반복된다.
- 지정한 범위의 바깥의 수가 종종 튀어나온다.

위 문제들은 Random.nextInt(int)를 사용하면 매우 쉽게 해결된다.

![Untitled](https://github.com/tkdals2317/effective-java/assets/49682056/a1925245-77f4-42f1-a49f-b72fe81c853d)

위 코드에서 조건문을 `rnd.nextInt(n) < n/2` 로만 바꿔도 정상적으로 500000만 근처의 값을 얻을 수 있었다.

```java
int low = 0;
for (int i = 0; i < 1000000; i++) {
    if (rnd.nextInt(n) < n/2) {
        low++;
    }
}
System.out.println(low);

==== output =====
50040
```

추가적으로 자바 7부터는 Random 대신 ThreadLocalRandom으로 대체하는 것을 추천한다. 

더 고품질의 무작위 수를 생성할 뿐만 아니라 속도도 더 빠르다.

**라이브러리를 사용시 이점**

- **이렇게 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.**
- **핵심적인 일과 크게 관련없는 문제를 해결하기 위해 시간을 허비 하지 않아도 된다.**
- **노력하지 않아도 성능이 지속해서 개선된다.**
- **기능이 점점 많아진다.**
- **내가 작성한 코드가 많은 사람에게 낯익은 코드가 되어, 자연스럽게 다른 개발자들이 읽기 쉽고, 유지보수, 재활용하기 좋은 코드가 된다.**

그럼에도 불구하고 많은 프로그래머가 라이브러리의 기능 대신 직접 구현하여 사용하고 있다.

WHY? 기능이 있는 지도 모르기 때문이다.

**라이브러리의 메이저 릴리스마다 주목할 만한 수많은 기능이 추가되니 API 문서를 읽어보는 것을 추천한다.**

라이브러리가 너무 방대하여 모든 API 문서를 읽는 것은 벅차겠지만 프로그래머라면 아래의 패키지들에는 익숙해지자

- java.lang
- java.util
- java.io
- java.util.concurrent
- 컬렉션 프레임워크
- 스트림 라이브러리

만약 표준 라이브러리에서 원하는 기능을 찾지 못하면 구글의 구아바 라이브러리처럼 적합한 서드파티 라이브러리를 사용하

### 정리

바퀴를 다시 발명하지 말자

아주 특별한 기능이 아닌 이상 누군가 이미 라이브러리 형태로 구현해놨을 가능성이 크다.

대부분의 라이브러리의 코드는 여러분이 직접 작성한거보다 품질이 좋고, 점차 개선될 가능성이 크다.

**라이브러리의 사용법을 익히고 API 문서를 읽어보는 습관을 들이자!** 

힘들게 직접 구현하지말고 라이브러리를 사용하여 코드 생산성을 많이 높일 수 있다.